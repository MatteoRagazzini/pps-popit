\section{Implementazione}
In questa sezione vengono analizzati gli aspetti implementativi del sistema, facendo eventualmente riferimento al codice
sviluppato. Nello specifico, verranno approfonditi solamente gli elementi che non sono stati esplorati a pieno nella
sezione Design di Dettaglio o che si ritengono fondamentali nello sviluppo di un progetto di tipo "game" come quello in
discussione. Per riflettere la suddivisione del lavoro durante il processo di sviluppo, questa sezione presenta una
parte descrittiva per ognuno dei membri del team.

\subsection{Tommaso Mandoloni}
Il mio compito all'interno del progetto, oltre che collaborare con il team per implementare aspetti e funzionalità
comuni di Model, Controller e design, è stato quello di strutturare e implementare le torri di gioco, intese come entità
di base, i loro potenziamenti e infine l'attore che ne incapsula il comportamento. Inoltre mi sono occupato di tutta
la parte di serializzazione e deserializzazione, in modo da poter wrappare gli oggetti in strutture dati salvabili su
file.

\subsubsection{File Coder}
L'oggetto \texttt{FileCoder} nasce dall'esigenza di poter salvare i dati di gioco su file in modo da poterli
ripristinare per dare all'utente la possibilità di rigiocare le sue partite preferite. In particolare si tratta della
possibilità per l'utente di poter salvare su file le sue mappe preferite in modo da poterle rigiocare. Il
\texttt{FileCoder} quindi lavora principalmente con due tipologie di strutture dati: un file \textit{json}, in cui
vengono indicizzate e salvate le mappe di gioco, e una lista di tracce.

Il suo compito è quello di serializzare e deserializzare il file \textit{json}, tenendolo aggiornato sulle nuove
tracce che l'utente intende salvare. Per supportare la fase implementativa è stata utilizzata la libreria \textit{io
.circe} che agevola la trasformazione di oggetti in file di tipo json. In particolare sono stati implementati due
\textit{custom codecs}, ossia un \texttt{Encoder} che permette di trasformare una lista di tracce nel rispettivo
oggetto \texttt{Json} che andrà poi salvato su file, mantenendone l'indicizzazione e la sequenza di coordinate delle
celle utilizzate per individuare la traccia di gioco, e un \texttt{Decoder} che svolge l'operazione contraria,
prendendo in input un oggetto Json e trasformandolo nella rispettiva lista di tracce, in modo da poterla modificare o
aggiornare durante la fase di gioco. Per realizzare entrambe le funzionalità di codifica, si è scelto di implementare
le operazioni all'interno di oggetti impliciti in modo che fosse sufficiente richiamare la codifica direttamente sul
tipo di file interessato: in questo modo infatti per trasformare una lista di tracce in un oggetto json, sarà
sufficiente richiamare il metodo \texttt{.asJson} direttamente su una \texttt{List[Track]}, mentre viceversa per
ritornare una lista di tracce da un oggetto json basterà invocare direttamente sull'oggetto il metodo \texttt{.as[List[Track]]}.

\input{code/coder.tex}

Le effettive operazioni di salvataggio su file e caricamento da esso, sono state implementate tramite
\textit{for-comprehension} sfruttando la libreria \textit{cats.effects.IO}, grazie alla quale è stato possibile
definire una sequenza di operazioni da eseguire incapsulandone i side effects, garantendone l'esecuzione in un
ambiente safe dal momento che si parla di scrittura e lettura su file esterni. In questo modo si riesce a mantenere
una struttura di codice molto pulita e intuitiva rispettando il KISS principle e sfruttando a pieno la programmazione
funzionale.

Compito estremamente importante del \texttt{FileCoder} è anche quello di eseguire un corretto setup dell'albero delle
directory di gioco una volta avviato. Infatti dovrà preoccuparsi di controllare se i le cartelle che conterranno i
file di gioco, ossia il \textit{json} delle tracce e gli screenshot delle mappe, in modo da non incorrere in errori
durante la fase di scrittura e lettura, e, in caso siano assenti, crearle a run-time. Anche in questo caso, per
rispettare il principio KISS e sfruttare i costrutti funzionali, si è scelto di creare all'interno di un
\texttt{Builder}, una monade appositamente strutturata per facilitare le operazioni di setup. Infatti in questo modo
sarà possibile controllare l'esistenza delle directories di gioco all'interno del file system ed eventualmente
crearle, tutto attraverso poche righe di codice eseguite all'interno di un metodo \texttt{setup} che sfrutta una
sequenza di operazioni eseguite tramite \textit{for-comprehension}.

\input{code/setup.tex}

\subsection{Alessandro Marcantoni}
Il mio compito all'interno del progetto è stato quello di realizzare il \texttt{GameLoop}, i palloncini (l'entità base,
i vari "potenziamenti" e infine il rispettivo attore), la gestione dei round (con relativa DSL per la loro creazione e
l'attore che si occupa dello \textit{spawn} dei palloncini) e la suddivisione della logica del model nei tre
\textit{manager}. Ho inoltre collaborato con gli altri membri del team durante la fase di design delle entità.

\subsubsection{Game Loop}
Il \textit{game loop} è il ciclo infinito che si occupa di aggiornare il \texttt{Model} ed ordinare il conseguente
\textit{refresh} della \texttt{View}. Solitamente esso viene implementato mediante un ciclo \texttt{while(true)} ma,
avendo adottato il paradigma ad attori, ciò comporterebbe l'esecuzione di un \textit{handler} bloccante con
conseguente perdita totale di reattività da parte dell'attore \texttt{GameLoop}.

Tale effetto è stato evitato mediante un comportamento che sfrutta un \textit{timer}: l'attore \texttt{GameLoop} invia a
se stesso dei messaggi di tipo \texttt{Tick} distanziati tra loro da un \textit{delay} che dipende dal
\textit{frame rate} scelto per la partita. Alla ricezione di tale messaggio il \texttt{GameLoop} ordina al
\texttt{Model} di aggiornarsi; una volta ottenuta la risposta da quest'ultimo, ordina alla \texttt{View} di renderizzare
la lista di entità provenienti dal \texttt{Model}. Le interazioni appena descritte sono riportate in figura
\ref{fig:sequence-gameloop}.

\begin{figure}[H]
    \centering
    \includegraphics[width=.5\linewidth]{img/sequence-gameloop}
    \caption{Diagramma di sequenza delle interazioni del \texttt{GameLoop}.}
    \label{fig:sequence-gameloop}
\end{figure}

\subsubsection{Palloncini}
I palloncini rappresentano una delle entità fondamentali del gioco. In particolare, essi sono in grado di muoversi
seguendo un percorso e possono essere scoppiati da un proiettile: pertanto, il \texttt{trait Balloon} estende il
\texttt{trait Entity} a cui aggiunge poi le abilità \texttt{TrackFollowing} e \texttt{Poppable} mediante il meccanismo
di \textbf{mixin}.

Per quanto riguarda la loro struttura, i palloncini possono essere \texttt{Simple}, se non ne includono altri al loro
interno, o \texttt{Complex} altrimenti. Tale implementazione permette di rappresentare in modo intuitivo l'effettivo
dominio in quanto, un palloncino complesso, quando scoppiato, deve mostrare il palloncino da lui nascosto.

\input{code/poppables}

Come mostrato nel listato \ref{code:poppables}, tale implementazione rispecchia quella di un \textbf{sum type}: struttura
dati tipica della programmazione funzionale.

Degni di nota all'interno del \texttt{trait Balloon} sono i metodi \texttt{change} e \texttt{retrieve}. I palloncini
espongono diversi metodi per accedere o cambiare il valore di proprietà che sono contenute all'interno del
\texttt{Simple}. Dato che l'implementazione di tali metodi sarebbe stata pressoché identica, per meglio aderire al
principio DRY si è deciso di introdurre i suddetti due metodi.
Infine, il metodo \texttt{pop} che elimina un numero di \textit{layer} di \texttt{Complex} pari al danno del proiettile
che colpisce il palloncino. Per fare ciò genera, a partire dal palloncino originale, uno \textit{stream} di questi dove
ognuno rappresenta il palloncino risultante dall'esplosione del precedente. L'utilizzo di \texttt{Option} ha permesso,
attraverso il comportamento monadico (sfruttato dal metodo \texttt{flatMap}), di gestire il caso in cui il palloncino
scoppi completamente e di portare avanti la computazione anche in tale situazione.

\input{code/pop}

Per quanto riguarda invece i potenziamenti dei palloncini, essi sono stati implementati sfruttando il pattern
\textbf{Decorator} \cite{gof}. Un potenziamento può quindi essere concettualmente pensato come un \textit{wrapper} per un
palloncino: grazie al pattern appena citato è inoltre possibile avvologere un palloncino con più potenziamenti
simultaneamente. In particolare, è stata implementata una classe astratta \texttt{BalloonDecoration} in cui vengono
ridefiniti alcuni metodi comuni alle decorazioni contrete. È stato definito il metodo \texttt{retrieve}: ciò rende i
metodi del \texttt{trait Balloon} che lo utilizzavano dei \textbf{Template Method} \cite{gof}. Inoltre, il metodo
\texttt{instance} che verrà definito dalle sotto-classi concrete e che permette di avvolgere un palloncino con un
potenziamento. Anche in questo caso viene sfruttato il pattern \textbf{Template Method}.

\subsection{Matteo Ragazzini}

\subsection{Simone Romagnoli}
Fungendo da \textit{product owner}, le porzioni di progetto di cui mi sono occupato sono molteplici: oltre ad aver 
proposto il design dell'architettura complessiva, ho partecipato all'implementazione di svariate parti del sistema e, a 
volte, ho rivalutato l'effettiva scrittura di alcune funzionalità. Di seguito, descrivo le parti significative del mio 
lavoro, focalizzandomi sugli aspetti implementativi importanti per la totalità del progetto.

\subsubsection{Tracce di gioco}
La mappa del gioco è descritta da una griglia invisibile composta da celle: le tracce non sono altro
che una sequenza ordinata di celle adiacenti, a partire dal bordo sinistro dello schermo, e a terminare in quello
destro. Per elaborare il tracciato che i palloncini seguono durante la partita, ho deciso di sfruttare la programmazione
logica, e, nello specifico, la libreria \texttt{it.unibo.alice.tuprolog} \cite{TuProlog}. In ausilio alla interazione
\textit{Scala-Prolog}, è stato implementato un motore specifico \ref{code:prolog-engine} che risolve le query in input,
trovando una traccia con fattori di casualità.

\input{code/engine}

Le query vengono formulate prendendo in input tre parametri:
\begin{itemize}
    \item una cella d'inizio;
    \item una cella di fine;
    \item la difficoltà di gioco.
\end{itemize}

Sulla base di questi, viene trovata una soluzione con la teoria sviluppata: il metodo tradizionale per trovare una
traccia, sarebbe quello di calcolare tutti i possibili percorsi dalla cella d'inizio a quella di fine e sceglierne uno
casualmente; tuttavia, questo approccio è risultato essere troppo oneroso, già a partire da griglie di dimensione
$5 \times 5$. Il metodo utilizzato per individuare una traccia soddisfacente, è stato quello di disegnarne una
introducendo fattori di casualità nel processo di scelta delle celle, ad esempio, implicando un cambiamento di direzione
sempre più probabile con l'aumentare di celle consecutive aventi lo stesso orientamento. Anche la difficoltà di gioco
è un fattore determinante: la traccia, infatti, non torna mai verso la cella d'inizio quando la difficoltà è difficile,
in modo da accorciare la traccia e facilitare i palloncini, mentre, in modalità facile, è più probabile ottenere una
traccia più lunga. Nel listato \ref{code:prolog-theory}, si mostra l'algoritmo di individuazione del percorso preso
dalla teoria \textit{prolog}.

\input{code/theory}

\subsubsection{Abilità di TrackFollowing}
Per muovere i palloncini sulla traccia, sarebbe corretto rispettare la gerarchia di entità mostrata nella sezione
Design di dettaglio, in particolare, senza modificare l'interfaccia \texttt{MovementAbility}, bensì aggiungendo una
funzionalità ad essa. Quindi è stato pensato un meccanismo che associa una posizione lineare al palloncino sulla
traccia bidimensionale: il \texttt{TrackFollowing}.

\input{code/track-following}

Il listato \ref{code:track-following} mostra come l'abilità di movimento viene sovrascritta seguendo la posizione
lineare nella traccia. Per approfondire, la posizione lineare è stata pensata come un \texttt{Double} la cui parte
intera rappresenta l'indice della cella occupata dal palloncino nella traccia, mentre la parte decimale indica la
percentuale attraversata della cella stessa.

\subsubsection{FXML Controllers}
\subsubsection{Rendering DSL}


