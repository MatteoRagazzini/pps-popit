\newpage
\section{Implementazione}
In questa sezione vengono analizzati gli aspetti implementativi del sistema, facendo eventualmente riferimento al codice
sviluppato. Nello specifico, verranno approfonditi solamente gli elementi che non sono stati esplorati a pieno nella
sezione Design di Dettaglio o che si ritengono fondamentali nello sviluppo di un progetto di tipo "game" come quello in
discussione. Per riflettere la suddivisione del lavoro durante il processo di sviluppo, questa sezione presenta una
parte descrittiva per ognuno dei membri del team.

\subsection{Tommaso Mandoloni}
Il mio compito all'interno del progetto, oltre che collaborare con il team per implementare aspetti e funzionalità
comuni di Model, Controller e design, è stato quello di strutturare e implementare le torri di gioco, intese come entità
di base, i loro potenziamenti e infine l'attore che ne incapsula il comportamento. Inoltre mi sono occupato di tutta
la parte di serializzazione e deserializzazione, in modo da poter wrappare gli oggetti in strutture dati salvabili su
file, oltre che nella collaborazione per la creazione di un attore che sfrutti queste funzionalità.

\subsubsection{File Coder}
L'oggetto \texttt{FileCoder} nasce dall'esigenza di poter salvare i dati di gioco su file in modo da poterli
ripristinare per dare all'utente la possibilità di rigiocare le sue partite preferite. In particolare si tratta della
possibilità per l'utente di poter salvare su file le sue mappe preferite in modo da poterle rigiocare. Il
\texttt{FileCoder} quindi lavora principalmente con due tipologie di strutture dati: un file \textit{json}, in cui
vengono indicizzate e salvate le mappe di gioco, e una lista di tracce.

Il suo compito è quello di serializzare e deserializzare il file \textit{json}, tenendolo aggiornato sulle nuove
tracce che l'utente intende salvare. Per supportare la fase implementativa è stata utilizzata la libreria \textit{io.circe}
\cite{circe} che agevola la trasformazione di oggetti in file di tipo json. In particolare sono stati implementati
due \textit{custom codecs}, ossia un \texttt{Encoder} che permette di trasformare una lista di tracce nel rispettivo
oggetto \texttt{Json} che andrà poi salvato su file, mantenendone l'indicizzazione e la sequenza di coordinate delle
celle utilizzate per individuare la traccia di gioco, e un \texttt{Decoder} che svolge l'operazione contraria,
prendendo in input un oggetto Json e trasformandolo nella rispettiva lista di tracce, in modo da poterla modificare o
aggiornare durante la fase di gioco. Per realizzare entrambe le funzionalità di codifica, si è scelto di implementare
le operazioni all'interno di oggetti impliciti in modo che fosse sufficiente richiamare la codifica direttamente sul
tipo di file interessato: in questo modo infatti per trasformare una lista di tracce in un oggetto json, sarà
sufficiente richiamare il metodo \texttt{.asJson} direttamente su una \texttt{List[Track]}, mentre viceversa per
ritornare una lista di tracce da un oggetto json basterà invocare direttamente sull'oggetto il metodo
\texttt{.as[List[Track]]}.

\input{code/coder.tex}

Le effettive operazioni di salvataggio su file e caricamento da esso, sono state implementate tramite
\textit{for-comprehension} sfruttando la libreria \textit{cats.effects.IO} \cite{cats-effects}, grazie alla quale è stato possibile
definire una sequenza di operazioni da eseguire incapsulandone i side effects, garantendone l'esecuzione in un
ambiente safe dal momento che si parla di scrittura e lettura su file esterni. In questo modo si riesce a mantenere
una struttura di codice molto pulita e intuitiva rispettando il KISS principle e sfruttando a pieno la programmazione
funzionale.

Compito estremamente importante del \texttt{FileCoder} è anche quello di eseguire un corretto setup dell'albero delle
directory di gioco una volta avviato. Infatti dovrà preoccuparsi di controllare se esistono le cartelle che
conterranno i file di gioco, ossia il \textit{json} delle tracce e gli screenshot delle mappe, in modo da non
incorrere in errori durante la fase di scrittura e lettura, e, in caso siano assenti, crearle a run-time. Anche in
questo caso, per rispettare il principio KISS e sfruttare i costrutti funzionali, si è scelto di creare all'interno
di un \texttt{Builder}, una monade appositamente strutturata per facilitare le operazioni di setup. Infatti in questo
modo sarà possibile controllare l'esistenza delle directories di gioco all'interno del file system ed eventualmente
crearle, tutto attraverso poche righe di codice eseguite all'interno di un metodo \texttt{setup} che sfrutta una
sequenza di operazioni eseguite tramite \textit{for-comprehension}.

\input{code/setup.tex}

\subsubsection{Torri}
Le torri, insieme ai pallonicini, sono le entità protagoniste del gioco. Infatti, una volta posizionato nella mappa
di gioco, potranno ruotare per mirare ai palloncini che passano all'interno del loro campo visivo, e sparare un
proiettile specifico verso la loro direzione per poterli scoppiare: pertanto il \texttt{trait Tower} estende
\texttt{Entity}, con l'aggiunta di \textbf{mixin} creati ad-hoc per conferire alla torre la capacità di visione di altre
entità che attraversano il suo campo visivo, e la capacità di sparare un proiettile nella direzione specificata.

Per quanto riguarda la struttura delle torri, come espressamente richiesto dai requisiti, esse devono essere
implementate secondo tre diverse tipologie. Per implentare tale requisito, come prima versione si è pensato di
utilizzare il pattern \textbf{Template Method} in modo da creare una classe astratta che rappresentasse una torre
base, ed estenderne le funzionalità implementando sotto classi specifiche. Questo approccio è stato però abbandonato
a seguito di un'analisi di progettazione più approfondita: infatti si è poi scelto di implementare una
\texttt{BaseTower} come \textbf{case class} che implementasse di default tutte le funzionalità che una torre di gioco
deve possedere. Attraverso questo approccio infatti è stato possibile mantenere una metodologia del tutto funzionale
per quanto riguarda la modifica dei valori delle caratteristiche della torre come la sua rotazione o il raggio del
campo visivo: infatti, al contrario di un approccio orientato agli oggetti dove una volta modificati i campi
richiesti veniva semplicemente aggiornato lo stesso oggetto, in questo caso attraverso l'utilizzo del meotodo
\textit{copy()} ogni volta che una torre deve aggiornare un suo campo, l'intero oggetto viene ricreato con i nuovi
valori. In questo modo anche il codice risulta essere più chiaro e pulito, oltre che più funzionale.

A questo punto, per mantenere la divisione delle torri per le varie tipologie, invece che creare delle sotto classi
per ogni tipo di torre, si è scelto di utilizzare un meccanismo puramente funzionale ossia le \textbf{type class}. Le
type class sono un costrutto tipicamente funzionale che supportano un meccanismo di polimorfismo ad-hoc, in grado
quindi di aggiungere funzionalità vincolate a un tipo di dato specifico ma senza toccare il codice. Infatti la classe
\texttt{BaseTower[B]} è una type class sul tipo di proiettile B che utilizza. Per istanziare quindi le varie
tipologie di torri, è stato adottata una rivisitazione del pattern \textbf{Builder}, specificando dei builder
impliciti che generano automaticamente il tipo di torre corretto passando in input il tipo di proiettile richiesto.

\input{code/tower-builder.tex}

Seguendo questo approccio e sfruttando le potenzialità delle type class, si riesce a garantire enorme flessibilità ed
estendibilità all'intera strttura delle torri, poiché nel caso venisse aggiunta in futura una nuova tipologia di
proiettile, sarà sufficiente creare lo specifico builder per istanziarne la tipologia di torre associata, senza
doverne implementare una classe specifica.

Al fine di agevolare la creazione delle torri di gioco, è stato creato un appostio DSL che permette di istanziare
tipologie di torri specifiche con pochissime righe di codice e in via del tutto funzionale: ad esempio per istanziare
una torre che lancia freccette, con i suoi valori default, basterà scrivere "Arrow tower spawn".

\input{code/tower-spawn.tex}

Inoltre ogni torre dispone di una funzionalità di \textit{boosting} aggiuntiva che le permette di incrementare i valori
dei suoi campi durante il gioco, in modo che con l'aumentare dei round e quindi della difficoltà, il giocatore riesca
comunque ad avere un supporto adeguato per vincere i round. Rimane nella strategia del player capire quando e quali
potenziamenti fornire alla torre, al fine di massimizzare il punteggio di gioco. La funzionalità di potenziamento
delle torri è stata implementata come una \textbf{implicit class} proprio sulla classe base della torre, in modo da
renderle diposnibile il metodo \textit{boost} anche se non fa parte della sua struttura fisica.

\subsection{Alessandro Marcantoni}
Il mio compito all'interno del progetto è stato quello di realizzare il \texttt{GameLoop}, i palloncini (l'entità base,
i vari "potenziamenti" e infine il rispettivo attore), la gestione dei round (con relativa DSL per la loro creazione e
l'attore che si occupa dello \textit{spawn} dei palloncini) e la suddivisione della logica del model nei tre
\textit{manager}. Ho inoltre collaborato con gli altri membri del team durante la fase di design delle entità.

\subsubsection{Game Loop}
Il \textit{game loop} è il ciclo infinito che si occupa di aggiornare il \texttt{Model} ed ordinare il conseguente
\textit{refresh} della \texttt{View}. Solitamente esso viene implementato mediante un ciclo \texttt{while(true)} ma,
avendo adottato il paradigma ad attori, ciò comporterebbe l'esecuzione di un \textit{handler} bloccante con
conseguente perdita totale di reattività da parte dell'attore \texttt{GameLoop}.

Tale effetto è stato evitato mediante un comportamento che sfrutta un \textit{timer}: l'attore \texttt{GameLoop} invia a
se stesso dei messaggi di tipo \texttt{Tick} distanziati tra loro da un \textit{delay} che dipende dal
\textit{frame rate} scelto per la partita. Alla ricezione di tale messaggio il \texttt{GameLoop} ordina al
\texttt{Model} di aggiornarsi; una volta ottenuta la risposta da quest'ultimo, ordina alla \texttt{View} di renderizzare
la lista di entità provenienti dal \texttt{Model}. Le interazioni appena descritte sono riportate in figura
\ref{fig:sequence-gameloop}.

\begin{figure}[H]
    \centering
    \includegraphics[width=.5\linewidth]{img/sequence-gameloop}
    \caption{Diagramma di sequenza delle interazioni del \texttt{GameLoop}.}
    \label{fig:sequence-gameloop}
\end{figure}

\subsubsection{Palloncini}
I palloncini rappresentano una delle entità fondamentali del gioco. In particolare, essi sono in grado di muoversi
seguendo un percorso e possono essere scoppiati da un proiettile: pertanto, il \texttt{trait Balloon} estende il
\texttt{trait Entity} a cui aggiunge poi le abilità \texttt{TrackFollowing} e \texttt{Poppable} mediante il meccanismo
di \textbf{mixin}.

Per quanto riguarda la loro struttura, i palloncini possono essere \texttt{Simple}, se non ne includono altri al loro
interno, o \texttt{Complex} altrimenti. Tale implementazione permette di rappresentare in modo intuitivo l'effettivo
dominio in quanto, un palloncino complesso, quando scoppiato, deve mostrare il palloncino da lui nascosto.

\input{code/poppables}

Come mostrato nel listato \ref{code:poppables}, tale implementazione rispecchia quella di un \textbf{sum type}: struttura
dati tipica della programmazione funzionale.

Degni di nota all'interno del \texttt{trait Balloon} sono i metodi \texttt{change} e \texttt{retrieve}. I palloncini
espongono diversi metodi per accedere o cambiare il valore di proprietà che sono contenute all'interno del
\texttt{Simple}. Dato che l'implementazione di tali metodi sarebbe stata pressoché identica, per meglio aderire al
principio DRY si è deciso di introdurre i suddetti due metodi.
Infine, il metodo \texttt{pop} che elimina un numero di \textit{layer} di \texttt{Complex} pari al danno del proiettile
che colpisce il palloncino. Per fare ciò genera, a partire dal palloncino originale, uno \textit{stream} di questi dove
ognuno rappresenta il palloncino risultante dall'esplosione del precedente. L'utilizzo di \texttt{Option} ha permesso,
attraverso il comportamento monadico (sfruttato dal metodo \texttt{flatMap}), di gestire il caso in cui il palloncino
scoppi completamente e di portare avanti la computazione anche in tale situazione.

\input{code/pop}

Per quanto riguarda invece i potenziamenti dei palloncini, essi sono stati implementati sfruttando il pattern
\textbf{Decorator} \cite{gof}. Un potenziamento può quindi essere concettualmente pensato come un \textit{wrapper} per un
palloncino: grazie al pattern appena citato è inoltre possibile avvologere un palloncino con più potenziamenti
simultaneamente. In particolare, è stata implementata una classe astratta \texttt{BalloonDecoration} in cui vengono
ridefiniti alcuni metodi comuni alle decorazioni contrete. È stato definito il metodo \texttt{retrieve}: ciò rende i
metodi del \texttt{trait Balloon} che lo utilizzavano dei \textbf{Template Method} \cite{gof}. Inoltre, il metodo
\texttt{instance} che verrà definito dalle sotto-classi concrete e che permette di avvolgere un palloncino con un
potenziamento. Anche in questo caso viene sfruttato il pattern \textbf{Template Method}.

Infine, l'attore del palloncino implementa tutti quei comportamenti che non sono intrinsechi al palloncino stesso ma che
riguardano interazioni con altre entità o con l'ambiente. Ad esempio, vengono effettuati controlli per capire se esso è
arrivato alla fine del percorso oppure ne vengono gestiti l'esplosione e il congelamento come mostrato in figura
\ref{fig:state-balloon-actor}.

\begin{figure}[H]
    \centering
    \includegraphics[width=.5\linewidth]{img/state-balloon-actor}
    \caption{Diagramma di stato dell'attore del palloncino.}
    \label{fig:state-balloon-actor}
\end{figure}

\subsubsection{Rounds}
I \textit{round} è rappresentato da una sequenza prestabilita di palloncini che attraversano il percorso e minacciano le
vite a disposizione del giocatore. All'interno di uno stesso \textit{round} possono essere presenti più "ondate" di
palloncini e queste ultime prendono il nome di \texttt{Streak}. L'implementazione più naturale consiste quindi nel
definire un \texttt{Round} come sequenza di \texttt{Streak}, ognuna delle quali è caratterizzata da diversi attributi:
\begin{itemize}
    \item La quantità di palloncini;
    \item Informazioni riguardo al tipo del palloncino: la sua vita ed eventuali potenziamenti;
    \item Il tempo che intercorre tra la generazione di un palloncino e quella del successivo.
\end{itemize}

Per poter definire in modo elegante e conciso un \texttt{Round}, è stata implementata una DSL che quindi permette di
utilizzare la sintassi indicata nel listato \ref{code:rounds} dove \texttt{n}, \texttt{m} e \texttt{l} rappresentano il
numero di palloncini all'interno della \texttt{Streak} corrispondente.
\input{code/rounds}

Inoltre, è stata resa disponibile anche una sintassi monadica per la definizione del \texttt{Round}. Tale approccio si è
rivelato utile soprattutto per la definizione di \textit{round} più complessi e per garantire maggiore flessiblità: il
precedente approccio obbligava infatti ad inserire tutte le \texttt{Streak} al momento della creazione di un'istanza di
\texttt{Round}, mentre in questo modo è possibile aggiungere \texttt{Streak} in momenti diversi e, quando si è
soddisfatti del risultato, generare il \texttt{Round} complessivo. È possibile apprezzare tale sintassi, realizzata
sfruttando la monade \texttt{IO} della libreria \textit{cats} \cite{cats-effects}, all'interno del listato
\ref{code:roundmonad}.
\input{code/round-monad}

\subsection{Matteo Ragazzini}

\subsection{Simone Romagnoli}
Fungendo da \textit{product owner}, le porzioni di progetto di cui mi sono occupato sono molteplici: oltre ad aver 
proposto il design dell'architettura complessiva, ho partecipato all'implementazione di svariate parti del sistema e, a 
volte, ho rivalutato l'effettiva scrittura di alcune funzionalità. Di seguito, descrivo le parti significative del mio 
lavoro, focalizzandomi sugli aspetti implementativi importanti per la totalità del progetto.

\subsubsection{Tracce di gioco}
La mappa del gioco è descritta da una griglia invisibile composta da celle: le tracce non sono altro
che una sequenza ordinata di celle adiacenti, a partire dal bordo sinistro dello schermo, e a terminare in quello
destro. Per elaborare il tracciato che i palloncini seguono durante la partita, ho deciso di sfruttare la programmazione
logica, e, nello specifico, la libreria \texttt{it.unibo.alice.tuprolog} \cite{tp}. In ausilio alla interazione
\textit{Scala-Prolog}, è stato implementato un motore specifico \ref{code:prolog-engine} che risolve le query in input,
trovando una traccia con fattori di casualità.

\input{code/engine}

Le query vengono formulate prendendo in input tre parametri:
\begin{itemize}
    \item una cella d'inizio;
    \item una cella di fine;
    \item la difficoltà di gioco.
\end{itemize}

Sulla base di questi, viene trovata una soluzione con la teoria sviluppata: il metodo tradizionale per trovare una
traccia, sarebbe quello di calcolare tutti i possibili percorsi dalla cella d'inizio a quella di fine e sceglierne uno
casualmente; tuttavia, questo approccio è risultato essere troppo oneroso, già a partire da griglie di dimensione
$5 \times 5$. Il metodo utilizzato per individuare una traccia soddisfacente, è stato quello di disegnarne una
introducendo fattori di casualità nel processo di scelta delle celle, ad esempio, implicando un cambiamento di direzione
sempre più probabile con l'aumentare di celle consecutive aventi lo stesso orientamento. Anche la difficoltà di gioco
è un fattore determinante: la traccia, infatti, non torna mai verso la cella d'inizio quando la difficoltà è difficile,
in modo da accorciare la traccia e facilitare i palloncini, mentre, in modalità facile, è più probabile ottenere una
traccia più lunga. Nel listato \ref{code:prolog-theory}, si mostra l'algoritmo di individuazione del percorso preso
dalla teoria \textit{prolog}.

\input{code/theory}

\subsubsection{Abilità di TrackFollowing}
Per muovere i palloncini sulla traccia, sarebbe corretto rispettare la gerarchia di entità mostrata nella sezione
Design di dettaglio, in particolare, senza modificare l'interfaccia \texttt{MovementAbility}, bensì aggiungendo una
funzionalità ad essa. Quindi è stato pensato un meccanismo che associa una posizione lineare al palloncino sulla
traccia bidimensionale: il \texttt{TrackFollowing}.

\input{code/track-following}

Il listato \ref{code:track-following} mostra come l'abilità di movimento viene sovrascritta seguendo la posizione
lineare nella traccia. Per approfondire, la posizione lineare è stata pensata come un \texttt{Double} la cui parte
intera rappresenta l'indice della cella occupata dal palloncino nella traccia, mentre la parte decimale indica la
percentuale attraversata della cella stessa.

\subsubsection{FXML Controllers}
\subsubsection{Rendering DSL}


